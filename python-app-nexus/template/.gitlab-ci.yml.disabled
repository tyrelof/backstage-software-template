workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - src/**/*
        - Dockerfile
        - charts/**/*
    - when: never

stages: [build, release]

variables:
  GIT_DEPTH: "1"
  APP_NAME: "${{ values.app_name }}"
  APP_ENV: "${{ values.app_env }}"
  IMAGE_REPO: "tyrelfecha/${{ values.app_name }}"
  COMMIT_ID: "${CI_COMMIT_SHORT_SHA}"

ci:
  stage: build
  tags: ["self-hosted","kaniko"]
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  variables:
    DOCKER_CONFIG: /kaniko/.docker
  before_script:
    - mkdir -p "$DOCKER_CONFIG"
    - AUTH="$(printf '%s:%s' "$DOCKERHUB_USERNAME" "$DOCKERHUB_TOKEN" | base64 | tr -d '\n')"
    - printf '{"auths":{"https://index.docker.io/v1/":{"auth":"%s"}}}\n' "$AUTH" > "$DOCKER_CONFIG/config.json"
  script: |
    /kaniko/executor \
      --context "${CI_PROJECT_DIR}" \
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile" \
      --destination "docker.io/${IMAGE_REPO}:${COMMIT_ID}" \
      --destination "docker.io/${IMAGE_REPO}:latest" \
      --cache=true \
      --cache-repo "docker.io/${IMAGE_REPO}"
    echo "COMMIT_ID=${COMMIT_ID}" >> build.env
  artifacts:
    reports: { dotenv: build.env }
    expire_in: 1 day

cd:
  stage: release
  tags: ["self-hosted"]
  image: tyrelfecha/argocd-yq:2.11.7
  before_script:
    - git config --global safe.directory "$CI_PROJECT_DIR"
    - git config user.name "Platform Bot"
    - git config user.email "platform-bot@noreply.local"
    - git remote set-url origin "https://oauth2:${PROJECT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch --all
    - git checkout "$CI_COMMIT_REF_NAME"
  script: |
    # 1) bump values
    FILE="charts/${APP_NAME}/values-${APP_ENV}.yaml"
    yq -i '.image.repository = strenv(IMAGE_REPO)' "$FILE"
    yq -i '.image.tag = strenv(COMMIT_ID)' "$FILE"

    # 2) commit with CI skip + push with skip (prevents a new pipeline)
    if ! git diff --quiet -- "$FILE"; then
      git add "$FILE"
      git commit -m "chore: image=${IMAGE_REPO}:${COMMIT_ID} (${APP_ENV}) [ci skip]"
      git push -o ci.skip origin "$CI_COMMIT_REF_NAME"
    else
      echo "No changes"
    fi

    # 3) ArgoCD login
    argocd login argocd-server.argocd --insecure --grpc-web \
      --username "${ARGOCD_USERNAME:-admin}" --password "$ARGOCD_PASSWORD"

    # 4) Always register a clean repo URL (no CI job token inside)
    REPO_URL_CLEAN="https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"

    # If a bad entry with gitlab-ci-token exists, remove it (one-time cleanup)
    if argocd repo list --output name | grep -Fxq "${CI_REPOSITORY_URL}"; then
      argocd repo rm "${CI_REPOSITORY_URL}" || true
    fi

    # (Re)register the clean URL with persistent creds (group/project token)
    # GitLab tokens over HTTPS use username 'oauth2'
    argocd repo add "${REPO_URL_CLEAN}" \
      --username oauth2 \
      --password "${PROJECT_PUSH_TOKEN}" \
      --upsert

    CHART_PATH="charts/${APP_NAME}"
    VALUES_FILE="values-${APP_ENV}.yaml"

    # Ensure the app points to the CLEAN URL
    if ! argocd app get "${APP_NAME}" >/dev/null 2>&1; then
      argocd app create "${APP_NAME}" \
        --repo "${REPO_URL_CLEAN}" \
        --path "${CHART_PATH}" \
        --dest-namespace "${APP_ENV}" \
        --dest-server https://kubernetes.default.svc \
        --values "${VALUES_FILE}" \
        --revision "${CI_COMMIT_BRANCH}" \
        --sync-policy manual \
        --sync-option CreateNamespace=true
    else
      argocd app set "${APP_NAME}" \
        --repo "${REPO_URL_CLEAN}" \
        --path "${CHART_PATH}" \
        --values "${VALUES_FILE}" \
        --revision "${CI_COMMIT_BRANCH}" \
        --dest-namespace "${APP_ENV}" \
        --dest-server https://kubernetes.default.svc
    fi

    # 5) Sync & wait
    argocd app sync "${APP_NAME}" --timeout 60
    argocd app wait "${APP_NAME}" --timeout 60