stages: [build, tag, deploy]

# These are rendered ONCE by Backstage during scaffolding
variables:
  APP_NAME: "${{ values.app_name }}"                 # e.g., python-app
  APP_ENV: "${{ values.app_env }}"                   # dev | prod
  IMAGE_REPO: "tyrelfecha/${{ values.app_name }}"    # Docker Hub namespace you use
  COMMIT_ID: "${CI_COMMIT_SHORT_SHA}"

# -------- CI JOBS --------

build:
  stage: build
  tags: ["self-hosted","kaniko"]
  image: gcr.io/kaniko-project/executor:latest
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - "src/**/*"
        - "Dockerfile"
        - "requirements.txt"
        - "charts/**/*"
  script:
    # Easiest auth: set a masked CI variable DOCKER_AUTH_CONFIG with JSON below:
    # {"auths":{"https://index.docker.io/v1/":{"auth":"<base64(DOCKERHUB_USERNAME:DOCKERHUB_TOKEN)>"}}}
    - /kaniko/executor
        --context "${CI_PROJECT_DIR}"
        --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
        --destination "${IMAGE_REPO}:${COMMIT_ID}"
        --destination "${IMAGE_REPO}:latest"
        --cache=true
        --cache-repo "${IMAGE_REPO}"
    - echo "COMMIT_ID=${COMMIT_ID}" >> build.env
  artifacts:
    reports: { dotenv: build.env }
    expire_in: 1 day

tag-values:
  stage: tag
  tags: ["self-hosted"]
  needs: ["build"]
  image: python:3.12-alpine
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  before_script:
    - apk add --no-cache git openssh-client
    - pip install yq
    - git config user.name  "Platform Bot"
    - git config user.email "platform-bot@noreply.local"
    # Allow CI job to push to the repo (enable in project settings)
    - git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch --all
    - git checkout "${CI_COMMIT_BRANCH}"
  script:
    - FILE="charts/${APP_NAME}/values-${APP_ENV}.yaml"
    - yq -Yi ".image.repository = \"${IMAGE_REPO}\"" "${FILE}"
    - yq -Yi ".image.tag = \"${COMMIT_ID}\"" "${FILE}"
    - git add "${FILE}"
    - git commit -m "chore: set image=${IMAGE_REPO}:${COMMIT_ID} for ${APP_ENV}"
    - git push origin "${CI_COMMIT_BRANCH}"

deploy:
  stage: deploy
  tags: ["self-hosted"]
  needs: ["tag-values"]
  image: alpine:3.20
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  before_script:
    - apk add --no-cache curl bash grep
    - curl -ksSL -o /usr/local/bin/argocd https://raw.githubusercontent.com/argoproj/argo-cd/stable/dist/argocd-linux-amd64
    - chmod +x /usr/local/bin/argocd
  script:
    - argocd login argocd-server.argocd --insecure --grpc-web \
        --username "${ARGOCD_USERNAME:-admin}" --password "$ARGOCD_PASSWORD"

    - REPO_URL="${CI_REPOSITORY_URL}"
    - argocd repo list | grep -q "$REPO_URL" || argocd repo add "$REPO_URL"

    - CHART_PATH="charts/${APP_NAME}"
    - VALUES_FILE="values-${APP_ENV}.yaml"

    - |
      if ! argocd app get "${APP_NAME}" >/dev/null 2>&1; then
        argocd app create "${APP_NAME}" \
          --repo "$REPO_URL" \
          --path "$CHART_PATH" \
          --dest-namespace "$APP_ENV" \
          --dest-server https://kubernetes.default.svc \
          --values "$VALUES_FILE" \
          --revision "$CI_COMMIT_BRANCH" \
          --sync-policy manual \
          --sync-option CreateNamespace=true
      fi

    - argocd app sync "${APP_NAME}"
    - argocd app wait "${APP_NAME}" --timeout 180
