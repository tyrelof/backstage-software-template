stages: [build, tag, deploy]

# These are rendered ONCE by Backstage during scaffolding
variables:
  APP_NAME: "${{ values.app_name }}"                 # e.g., python-app
  APP_ENV: "${{ values.app_env }}"                   # dev | prod
  IMAGE_REPO: "tyrelfecha/${{ values.app_name }}"    # Docker Hub namespace you use
  COMMIT_ID: "${CI_COMMIT_SHORT_SHA}"

# -------- CI JOBS --------

build:
  stage: build
  tags: ["self-hosted","kaniko"]
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]                 # important: let GitLab provide the shell
  variables:
    DOCKER_CONFIG: /kaniko/.docker   # where Kaniko reads auth from
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - "src/**/*"
        - "Dockerfile"
        - "requirements.txt"
        - "charts/**/*"
  before_script:
    - mkdir -p "$DOCKER_CONFIG"
    - echo "$DOCKER_AUTH_CONFIG" > "$DOCKER_CONFIG/config.json"
    # - AUTH="$(printf '%s:%s' "$DOCKERHUB_USERNAME" "$DOCKERHUB_TOKEN" | base64 | tr -d '\n')"
    # - printf '{"auths":{"https://index.docker.io/v1/":{"auth":"%s"}}}\n' "$AUTH" > "$DOCKER_CONFIG/config.json"
  script:
    # Make sure DOCKER_AUTH_CONFIG is set as a masked var at Group/Project level.
    # Example value: {"auths":{"https://index.docker.io/v1/":{"auth":"<base64(USER:TOKEN)>"}}}
    - /kaniko/executor
        --context "${CI_PROJECT_DIR}"
        --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
        --destination "${IMAGE_REPO}:${COMMIT_ID}"
        --destination "${IMAGE_REPO}:latest"
        --cache=true
        --cache-repo "${IMAGE_REPO}"
    - echo "COMMIT_ID=${COMMIT_ID}" >> build.env
  artifacts:
    reports: { dotenv: build.env }
    expire_in: 1 day

tag-values:
  stage: tag
  tags: ["self-hosted"]
  image: alpine:3.20
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  before_script:
    - apk add --no-cache git yq
    - git config --global safe.directory "$CI_PROJECT_DIR"
    - git config user.name "Platform Bot"
    - git config user.email "platform-bot@noreply.local"
    - git remote set-url origin "https://oauth2:${PROJECT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch --all
    - git checkout "$CI_COMMIT_REF_NAME"
  script:
    - COMMIT_ID="$CI_COMMIT_SHORT_SHA"
    - FILE="charts/${APP_NAME}/values-${APP_ENV}.yaml"
    - yq -i '.image.repository = strenv(IMAGE_REPO)' "$FILE"
    - yq -i '.image.tag = strenv(COMMIT_ID)' "$FILE"
    - git add "$FILE"
    - 'git commit -m "chore: image=${IMAGE_REPO}:${COMMIT_ID} (${APP_ENV})" || true'
    - git push origin "$CI_COMMIT_REF_NAME"

deploy:
  stage: deploy
  tags: ["self-hosted"]
  needs: ["tag-values"]
  image: alpine:3.20
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  before_script:
    - apk add --no-cache curl bash grep
    - curl -ksSL -o /usr/local/bin/argocd https://raw.githubusercontent.com/argoproj/argo-cd/stable/dist/argocd-linux-amd64
    - chmod +x /usr/local/bin/argocd
  script:
    - argocd login argocd-server.argocd --insecure --grpc-web \
        --username "${ARGOCD_USERNAME:-admin}" --password "$ARGOCD_PASSWORD"

    - REPO_URL="${CI_REPOSITORY_URL}"
    - argocd repo list | grep -q "$REPO_URL" || argocd repo add "$REPO_URL"

    # If your repo is private, pass creds to ArgoCD on first add:
    # - REPO_URL="${CI_REPOSITORY_URL}"
    # - |
    #   if ! argocd repo list | grep -q "$REPO_URL"; then
    #     argocd repo add "$REPO_URL" \
    #       --username oauth2 \
    #       --password "$PROJECT_PUSH_TOKEN" || true
    #   fi

    - CHART_PATH="charts/${APP_NAME}"
    - VALUES_FILE="values-${APP_ENV}.yaml"

    - |
      if ! argocd app get "${APP_NAME}" >/dev/null 2>&1; then
        argocd app create "${APP_NAME}" \
          --repo "$REPO_URL" \
          --path "$CHART_PATH" \
          --dest-namespace "$APP_ENV" \
          --dest-server https://kubernetes.default.svc \
          --values "$VALUES_FILE" \
          --revision "$CI_COMMIT_BRANCH" \
          --sync-policy manual \
          --sync-option CreateNamespace=true
      fi

    - argocd app sync "${APP_NAME}"
    - argocd app wait "${APP_NAME}" --timeout 180
