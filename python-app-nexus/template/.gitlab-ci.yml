workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - src/**/*
        - Dockerfile
        - charts/**/*
    - when: never

stages: [build, release]

variables:
  GIT_DEPTH: "1"
  APP_NAME: "${{ values.app_name }}"
  APP_ENV:  "${{ values.app_env }}"
  AWS_REGION: "${AWS_DEFAULT_REGION}"
  ECR_REGISTRY: "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
  IMAGE_REPO: "${ECR_REGISTRY}/${{ values.app_name }}"
  COMMIT_ID: "${CI_COMMIT_SHORT_SHA}"

build:
  stage: build
  tags: ["self-hosted","kaniko"]
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  variables:
    DOCKER_CONFIG: /kaniko/.docker
  before_script:
    - apk add --no-cache python3 py3-pip jq
    - pip install --no-cache-dir awscli
    - mkdir -p "$DOCKER_CONFIG"
    # Create repo if missing (optional but nice)
    - |
      aws ecr describe-repositories \
        --repository-names "${APP_NAME}" \
        --region "${AWS_REGION}" >/dev/null 2>&1 || \
      aws ecr create-repository \
        --repository-name "${APP_NAME}" \
        --image-scanning-configuration scanOnPush=true \
        --region "${AWS_REGION}"
    # Write config.json with base64("AWS:<password>") for ECR
    - PASS="$(aws ecr get-login-password --region "${AWS_REGION}")"
    - AUTH="$(printf 'AWS:%s' "$PASS" | base64 | tr -d '\n')"
    - printf '{"auths":{"https://%s":{"auth":"%s"}}}\n' "${ECR_REGISTRY}" "${AUTH}" > "$DOCKER_CONFIG/config.json"
  script: |
    /kaniko/executor \
      --context "${CI_PROJECT_DIR}" \
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile" \
      --destination "${IMAGE_REPO}:${COMMIT_ID}" \
      --destination "${IMAGE_REPO}:latest" \
      --cache=true \
      --cache-repo "${IMAGE_REPO}"


cd:
  stage: release
  tags: ["self-hosted"]
  image: tyrelfecha/argocd-yq:2.11.7
  before_script:
    - git config --global safe.directory "$CI_PROJECT_DIR"
    - git config user.name "Platform Bot"
    - git config user.email "platform-bot@noreply.local"
    - git remote set-url origin "https://oauth2:${PROJECT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch --all
    - git checkout "$CI_COMMIT_REF_NAME"
  script: |
    set -euo pipefail

    # 1) bump values
    FILE="charts/${APP_NAME}/values-${APP_ENV}.yaml"
    yq -i '.image.repository = strenv(IMAGE_REPO)' "$FILE"
    yq -i '.image.tag = strenv(COMMIT_ID)' "$FILE"

    # 2) commit with CI skip + push with skip (prevents a new pipeline)
    if ! git diff --quiet -- "$FILE"; then
      git add "$FILE"
      git commit -m "chore: image=${IMAGE_REPO}:${COMMIT_ID} (${APP_ENV}) [ci skip]"
      git push -o ci.skip origin "$CI_COMMIT_REF_NAME"
    else
      echo "No changes"
    fi

    # 3) ArgoCD login
    argocd login argocd-server.argocd --insecure --grpc-web \
      --username "${ARGOCD_USERNAME:-admin}" --password "$ARGOCD_PASSWORD"

    # 4) Register clean repo URL with persistent creds (not the CI job token)
    REPO_URL_CLEAN="https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    argocd repo add "${REPO_URL_CLEAN}" \
      --username oauth2 \
      --password "${PROJECT_PUSH_TOKEN}" \
      --upsert

    CHART_PATH="charts/${APP_NAME}"
    VALUES_FILE="values-${APP_ENV}.yaml"

    # 5) Create/update app, then sync & wait
    if ! argocd app get "${APP_NAME}" >/dev/null 2>&1; then
      argocd app create "${APP_NAME}" \
        --repo "${REPO_URL_CLEAN}" \
        --path "${CHART_PATH}" \
        --dest-namespace "${APP_ENV}" \
        --dest-server https://kubernetes.default.svc \
        --values "${VALUES_FILE}" \
        --revision "${CI_COMMIT_BRANCH}" \
        --sync-policy manual \
        --sync-option CreateNamespace=true
    else
      argocd app set "${APP_NAME}" \
        --repo "${REPO_URL_CLEAN}" \
        --path "${CHART_PATH}" \
        --values "${VALUES_FILE}" \
        --revision "${CI_COMMIT_BRANCH}" \
        --dest-namespace "${APP_ENV}" \
        --dest-server https://kubernetes.default.svc
    fi

    argocd app sync "${APP_NAME}" --timeout 60
    argocd app wait "${APP_NAME}" --timeout 60
