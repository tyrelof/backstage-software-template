workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - src/**/*
        - Dockerfile
        - charts/**/*
        - .gitlab-ci.yml
    - when: never

stages: [build, release]

variables:
  GIT_DEPTH: "1"
  APP_NAME: "${{ values.app_name }}"
  AWS_REGION: "${AWS_DEFAULT_REGION}"
  ECR_REGISTRY: "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
  IMAGE_REPO: "${ECR_REGISTRY}/${{ values.app_name }}"
  COMMIT_ID: "${CI_COMMIT_SHORT_SHA}"

build:
  stage: build
  tags: ["self-hosted","kaniko"]
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  variables:
    DOCKER_CONFIG: /kaniko/.docker
  before_script:
    - apk add --no-cache python3 py3-pip jq
    - pip install --no-cache-dir awscli
    - mkdir -p "$DOCKER_CONFIG"
    - |
      aws ecr describe-repositories \
        --repository-names "${APP_NAME}" \
        --region "${AWS_REGION}" >/dev/null 2>&1 || \
      aws ecr create-repository \
        --repository-name "${APP_NAME}" \
        --image-scanning-configuration scanOnPush=true \
        --region "${AWS_REGION}"
    - PASS="$(aws ecr get-login-password --region "${AWS_REGION}")"
    - AUTH="$(printf 'AWS:%s' "$PASS" | base64 | tr -d '\n')"
    - printf '{"auths":{"https://%s":{"auth":"%s"}}}\n' "${ECR_REGISTRY}" "${AUTH}" > "$DOCKER_CONFIG/config.json"
  script: |
    /kaniko/executor \
      --context "${CI_PROJECT_DIR}" \
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile" \
      --destination "${IMAGE_REPO}:${COMMIT_ID}" \
      --destination "${IMAGE_REPO}:latest" \
      --cache=true \
      --cache-repo "${IMAGE_REPO}"

# -----------------------------
# Shared deploy logic
# -----------------------------
.deploy:
  stage: release
  tags: ["self-hosted"]
  image: tyrelfecha/argocd-yq:2.11.7
  before_script:
    - git config --global safe.directory "$CI_PROJECT_DIR"
    - git config user.name "Platform Bot"
    - git config user.email "platform-bot@noreply.local"
    - git remote set-url origin "https://oauth2:${PROJECT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch --all
    - git checkout "$CI_COMMIT_REF_NAME"
  script: |
    set -euo pipefail

    if [ -z "${APP_ENV}" ]; then
      echo "ERROR: APP_ENV is empty"
      exit 1
    fi

    FILE="charts/${APP_NAME}/values-${APP_ENV}.yaml"
    if [ ! -f "$FILE" ]; then
      echo "ERROR: values file not found: $FILE"
      exit 1
    fi

    yq -i '.image.repository = strenv(IMAGE_REPO)' "$FILE"
    yq -i '.image.tag = strenv(COMMIT_ID)' "$FILE"

    if ! git diff --quiet -- "$FILE"; then
      git add "$FILE"
      git commit -m "chore: image=${IMAGE_REPO}:${COMMIT_ID} (${APP_ENV}) [ci skip]"
      git push -o ci.skip origin "$CI_COMMIT_REF_NAME"
    else
      echo "No changes"
    fi

    argocd login argocd-server.argocd --insecure --grpc-web \
      --username "${ARGOCD_USERNAME:-admin}" --password "$ARGOCD_PASSWORD"

    REPO_URL_CLEAN="https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    argocd repo add "${REPO_URL_CLEAN}" \
      --username oauth2 \
      --password "${PROJECT_PUSH_TOKEN}" \
      --upsert

    CHART_PATH="charts/${APP_NAME}"
    VALUES_FILE="values-${APP_ENV}.yaml"

    ARGO_APP="${APP_NAME}-${APP_ENV}"
    DEST_NS="${APP_NAME}-${APP_ENV}"

    if ! argocd app get "${ARGO_APP}" >/dev/null 2>&1; then
      argocd app create "${ARGO_APP}" \
        --repo "${REPO_URL_CLEAN}" \
        --path "${CHART_PATH}" \
        --dest-namespace "${DEST_NS}" \
        --dest-server https://kubernetes.default.svc \
        --values "${VALUES_FILE}" \
        --revision "${CI_COMMIT_BRANCH}" \
        --sync-policy manual \
        --sync-option CreateNamespace=true
    else
      argocd app set "${ARGO_APP}" \
        --repo "${REPO_URL_CLEAN}" \
        --path "${CHART_PATH}" \
        --values "${VALUES_FILE}" \
        --revision "${CI_COMMIT_BRANCH}" \
        --dest-namespace "${DEST_NS}" \
        --dest-server https://kubernetes.default.svc
    fi

    argocd app sync "${ARGO_APP}" --timeout 180
    argocd app wait "${ARGO_APP}" --timeout 180

deploy_stage:
  extends: .deploy
  variables:
    APP_ENV: "stage"

deploy_prod:
  extends: .deploy
  when: manual
  variables:
    APP_ENV: "prod"
